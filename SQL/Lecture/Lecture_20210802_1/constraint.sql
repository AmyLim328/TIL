/* 제약조건 (constraint)
 * : 테이블에 저장할 데이터에 대한 규칙
 * : 데이터 정의어 (DDL)과 같이 사용
 * 
 * 1) NOT NULL: 지정한 열에 NULL 허용하지 않음
 * (데이터 중복은 허용 => user1: scott, user2: scott)
 * 2) UNIQUE: 지정한 열이 유일한 값 (중복 X)
 * (데이터에 NULL은 중복 제외)
 * 3) PRIMARY KEY (기본키): 유일한 값 + NULL을 허용하지 않음
 * (하나의 테이블에 하나만 지정할 수 있음)
 * 4) FOREIGN KEY (외래키): 다른 테이블의 열 참조하는 값만 입력 가능
 * 5) CHECK: 조건식에 만족하는 데이터만 입력 가능
 * 
 * * 테이블이 생성될 때 제약조건을 같이 지정 (보통)
 * * 나중에 테이블 변경시에도 지정할 수는 있음
 * */

-- 테이블 생성 
-- EX) GAME_ID_PASS
-- GAME_ID VARCHAR(20) NOT NULL
-- GAME_PASS VARCHAR(20) NOT NULL
-- LASTDATE DATE

-- 1) NOT NULL
CREATE TABLE GAME_ID_PASS(
	GAME_ID VARCHAR(20) NOT NULL,
	GAME_PASS VARCHAR(20) NOT NULL,
	LASTDATE DATE
);

SELECT * FROM GAME_ID_PASS;

-- ID, PASS, LASTDATE를 INSERT INTO
INSERT INTO GAME_ID_PASS
VALUES ('eunbin', '1234', SYSDATE);

-- GAME_ID, GAME_PASS에 데이터를 넣지 않음 (오류)
INSERT INTO GAME_ID_PASS(LASTDATE)
VALUES (SYSDATE);

-- GAME_PASS에 NULL을 넣을 수가 없음 (오류)
INSERT INTO GAME_ID_PASS
VALUES ('eunbin', NULL, SYSDATE);

SELECT * FROM GAME_ID_PASS;

-- GAME_PASS만 NULL으로 변경 (오류)
UPDATE GAME_ID_PASS
SET GAME_PASS = NULL
WHERE GAME_ID = 'eunbin';

-- 제약 조건 조회
SELECT * FROM USER_CONSTRAINTS;
/* OWNER: 제약 조건 소유 계정
 * CONSTRAINT_NAME: 제약 조건 이름 (생략시 오라클 자동 생성)
 * CONSTRAINT_TYPE: 제약 조건 종류
 * C: CHECK, NOT NULL
 * U: UNIQUE
 * P: PRIMARY KEY
 * R: FOREIGN KEY
 * V: VIEW에서 WITH CHECK OPTION
 * O: VIEW에서 WITH READ ONLY
 * */


-- 제약 조건 이름 지정
-- >> 제약 조건 관리를 위해 이름을 지정해주는 것이 좋음
CREATE TABLE GAME_ID_PASS_CONS_NAME(
	GAME_ID VARCHAR(20) CONSTRAINT ID_NN NOT NULL,
	GAME_PASS VARCHAR(20) CONSTRAINT PASS_NN NOT NULL,
	LASTDATE DATE
);

SELECT * FROM USER_CONSTRAINTS;

-- 이미 생성한 테이블에 제약 조건 추가
/* 형식)
 * ALTER TABLE 테이블명
 * MODIFY (열이름 제약조건)
 */

-- 제약 조건 추가
ALTER TABLE GAME_ID_PASS_CONS_NAME
MODIFY (LASTDATE CONSTRAINT LD_NN NOT NULL);

-- 제약 조건 삭제
ALTER TABLE GAME_ID_PASS_CONS_NAME
DROP CONSTRAINT SYS_C007023;

SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 이름 변경 (기존에 동일한 제약조건 이름이 있으면 오류!)
ALTER TABLE GAME_ID_PASS
RENAME CONSTRAINT SYS_C007019 TO ID_NN2;

-- SYS_C007020, C007018의 이름 변경
ALTER TABLE GAME_ID_PASS
RENAME CONSTRAINT SYS_C007020 TO PASS_NN2;

-- 확인!
ALTER VIEW VW_EMP
RENAME CONSTRAINT SYS_C007018 TO VW_EMP_CHECK;

ALTER TABLE GAME_ID_PASS
DROP CONSTRAINT ID_NN2;

ALTER TABLE GAME_ID_PASS
DROP CONSTRAINT PASS_NN2;

SELECT * FROM USER_CONSTRAINTS;

-- 2) UNIQUE
-- : 데이터의 중복을 허용 X
-- : NULL값은 중복에 포함되지 않음 (NULL 여러 개 가능)

-- STUDENT 테이블
-- ID: UNIQUE => ID_UQ
-- NAME: NOT NULL => NAME_NN
-- PHONE
SELECT * FROM TAB;

DROP TABLE STUDENT;
CREATE TABLE STUDENT(
	ID VARCHAR(20) CONSTRAINT ID_UQ UNIQUE,
	NAME VARCHAR(20) CONSTRAINT NAME_NN NOT NULL,
	PHONE VARCHAR(20)
);


SELECT * FROM USER_CONSTRAINTS;

-- 데이터 삽입 2명 (ID가 같은)
INSERT INTO STUDENT
VALUES ('2021001', '홍길동', '010-1234-5678');
INSERT INTO STUDENT -- ID UNIQUE 제약조건 위배
VALUES ('2021001', '홍길순', '010-1234-1234');

-- 데이터 삽입 2명 (ID가 NULL) -- UNIQUE 제약조건 위배 X
INSERT INTO STUDENT
VALUES (NULL, '홍길동', '010-1234-5678');
INSERT INTO STUDENT 
VALUES (NULL, '홍길순', '010-1234-1234');

SELECT * FROM STUDENT;

SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 삭제
ALTER TABLE STUDENT
DROP CONSTRAINT ID_UQ;


-- 제약 조건 추가 (ID_UQ)
-- 제약 조건 추가 불가! (이미 ID가 UNIQUE 하지 않음)
ALTER TABLE STUDENT
MODIFY (ID CONSTRAINT ID_UQ UNIQUE);

DELETE FROM STUDENT
WHERE ID = '2021001' AND NAME = '홍길순';

SELECT * FROM STUDENT;
SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 이름 변경 (ID_UQ -> ID_UNIQUE)
ALTER TABLE STUDENT
RENAME CONSTRAINT ID_UQ TO ID_UNIQUE;


-- 3) PRIMARY KEY (기본키)
-- : UNIQUE + NOT NULL
-- : 기본키가 다른 데이터를 대표할 수 있는 열로 지정
-- : 테이블에서 오직 한 개만 존재
-- : 해당 열에는 자동으로 인덱스 만들어짐 (보통 기본키가 SELECT문에 자주 사용) 

-- Q1. PERSON이라는 TABLE을 생성
-- ID NUMBER(2)
-- NAME VARCHAR(20)
-- GENDER VARCHAR(5)
-- REGISTRATION VARCHAR(15)

-- A. PRIMARY KEY(기본키)가 될 수 있는 열 (+ 제약 조건 이름 지정)
-- B. NAME NOT NULL (+ 제약 조건 이름 지정)

CREATE TABLE PERSON( -- 열 레벨/인 라인 제약 조건 정의
	ID NUMBER(2) CONSTRAINT PID_PK PRIMARY KEY,
	NAME VARCHAR(20) CONSTRAINT PNAME_NN NOT NULL,
	GENDER VARCHAR(5),
	REGISTRATION VARCHAR(15)
);

CREATE TABLE PERSON( -- 테이블 레벨/아웃 라인 제약 조건 정의
	ID NUMBER(2),
	NAME VARCHAR(20),
	GENDER VARCHAR(5),
	REGISTRATION VARCHAR(15),
	CONSTRAINT PID_PK PRIMARY KEY (ID),
--	CONSTRAINT PNAME_NN NOT NULL (NAME)
	-- 테이블 레벨 제약 조건 정의는 NOT NULL 지정할 수 없음
	-- PRIMARY KEY, UNIQUE, FOREIGN KEY ....
);

SELECT * FROM USER_CONSTRAINTS;

-- PRIMARY KEY (기본키)는 데이터를 식별하는 유일한 값 
-- (SELECT 문에 많이 사용 => INDEX로 지정)
-- 인덱스 이름은 제약 조건 이름과 동일해짐
SELECT * FROM USER_INDEXES;


-- PERSON 테이블에 총 5명을 삽입
-- 1) PERSON 테이블에 ID는 SEQUENCE를 통해 생성 (SEQ_PERSON)
-- START WITH: 1
-- MINVALUE: 1
-- MAXVALUE: 5
-- INCREMENT BY: 1
-- CYCLE
-- NOCACHE

CREATE SEQUENCE SEQ_PERSON
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 5
CYCLE
NOCACHE;

SELECT * FROM USER_SEQUENCES;

-- 2) SEQ_PERSON을 통해 데이터 삽입
INSERT INTO PERSON (ID, NAME)
VALUES (SEQ_PERSON.NEXTVAL, '홍길동');
-- 총 6번을 실행하면 UNIQUE 조건에 만족하지 않음

SELECT * FROM PERSON;

INSERT INTO PERSON (ID, NAME)
VALUES (NULL, '홍길동');
-- NOT NULL 조건에 만족하지 않음

-- ALTER, MODIFY, RENAME, DROP문 작성할 수 있음!

-- 4) FOREIGN KEY (외래키, 외부키)
-- : 두 테이블의 관계 정의하는 제약 조건
-- ex) EMP, DEPT 
-- (EMP 테이블에서 DEPTNO는 외래키, DEPT 테이블에서 DEPTNO는 기본키)

SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM EMP;
SELECT * FROM DEPT;

INSERT INTO EMP(EMPNO, ENAME, JOB, DEPTNO)
VALUES (5000, '이클립', 'DEVELOPER', 50);
-- 외래키가 참조하는 DEPT.DEPTNO에 50이 없기 때문에 오류

INSERT INTO EMP(EMPNO, ENAME, JOB, DEPTNO)
VALUES (5000, '이클립', 'DEVELOPER', NULL);
-- 외래키 지정: 참조하는 테이블의 기본키이거나 
-- NULL인 값 ('참조할 데이터가 없다!') 지정 가능!
-- 외래키가 NULL인 경우 JOIN을 하면 결과 테이블?
-- : 외래키가 NULL인 행 제외

SELECT *
FROM EMP JOIN DEPT ON (EMP.DEPTNO = DEPT.DEPTNO);

SELECT * FROM EMP;


-- FOREGIN KEY 지정
/* CREATE TABLE 테이블명(
 * 	.... (다른 열 정의),
 * 	열 자료형 CONSTRAINT [제약조건 이름 (선택)] REFERENCES 참조 테이블 (열)
 * );
 * 
 * CREATE TABLE 테이블명(
 * 	.... (다른 열 정의),
 * 	열 자료형,
 *  CONSTRAINT [제약조건 이름 (선택)] FOREIGN KEY (열 이름)
 *  REFERENCES 참조 테이블 (열)
 * );
 * 
 * */


-- DEPT_FK 테이블 생성
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2) CONSTRAINT DEPT_FK_PK PRIMARY KEY,
	DNAME VARCHAR(20),
	LOC VARCHAR(20)
);

-- EMP_FK 테이블 생성 (DEPT_FK의 DEPTNO를 참조)
-- 기본키: EMPNO
-- 외래키: DEPTNO
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) CONSTRAINT EMP_FK_PK PRIMARY KEY,
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) CONSTRAINT EMP_FK_FK REFERENCES DEPT_FK (DEPTNO)
);

CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMP_FK_PK PRIMARY KEY (EMPNO),
	CONSTRAINT EMP_FK_FK FOREIGN KEY (DEPTNO) 
	REFERENCES DEPT_FK (DEPTNO)
);

INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (1000, '홍길동', 10);
-- 외래키가 참조할 DEPTNO 생성되지 않은 채로 데이터 삽입이 불가능

INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUTING', 'SEOUL');
-- 먼저 DEPTNO를 생성한 다음에 (1000, '홍길동', 10) 데이터 삽입 가능

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;
-- 오류 발생!
-- DEPTNO 10번을 참조하고 있는 레코드가 존재 ('홍길동')

/* 1. EMP 테이블의 '홍길동' 삭제하고 DEPT 테이블에 10번을 삭제
 * 2. EMP 테이블의 '홍길동'의 DEPTNO를 NULL 수정
 * 3. EMP 테이블의 FOREIGN KEY 제약조건 삭제
 * 
 * * FOREIGN KEY는 수정이 빈번하지 않은 열을 참조하는 게 좋음!
 * */

/* ON DELETE CASCADE: DEPT 테이블에 10번이 삭제될 경우에
 * 이를 참조하는 데이터를 함께 삭제
 * 
 * ON DELETE SET NULL: DEPT 테이블에 10번이 삭제될 경우에
 * 이를 참조하는 데이터를 NULL로 설정
 * */

DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) CONSTRAINT EMP_FK_PK PRIMARY KEY,
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) 
	CONSTRAINT EMP_FK_FK 
	REFERENCES DEPT_FK (DEPTNO) ON DELETE CASCADE
);

DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMP_FK_PK PRIMARY KEY (EMPNO),
	CONSTRAINT EMP_FK_FK FOREIGN KEY (DEPTNO) 
	REFERENCES DEPT_FK (DEPTNO) ON DELETE SET NULL
);

-- Q1. EMP_FK, DEPT_FK를 생성
-- 1) ON DELETE SET NULL
INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING', 'SEOUL');
INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (1000, '홍길동', 10);

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

-- NULL으로 수정 (ON DELETE SET NULL 방식 이용)
SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

-- 2) ON DELETE CASCADE
INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING', 'SEOUL');
INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (2000, '홍길동', 10);

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;


DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

-- 데이터가 다 사라짐 (ON DELETE CASCADE 방식 이용)
SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

